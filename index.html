<!DOCTYPE html>
<html lang="ar">
<head>
  <meta charset="utf-8" />
  <title>Heart Particles + Letter-by-letter Text + Speed Ã—1.5</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { margin:0; overflow:hidden; background:#050006; }
    canvas { display:block; }
    svg { display:none; }
    .hint { position: absolute; left:12px; top:12px; color:#fff8; font-family: Arial; font-size:13px; z-index:2; }
  </style>
</head>
<body>
  <svg viewBox="0 0 600 552">
    <path id="heartPath" d="M300,107.77C284.68,55.67,239.76,0,162.31,0,64.83,0,0,82.08,0,171.71c0,.48,0,.95,0,1.43-.52,19.5,0,217.94,299.87,379.69v0l0,0,.05,0,0,0,0,0v0C600,391.08,600.48,192.64,600,173.14c0-.48,0-.95,0-1.43C600,82.08,535.17,0,437.69,0,360.24,0,315.32,55.67,300,107.77" fill="#ee5282"/>
  </svg>

  <script src="https://cdn.jsdelivr.net/npm/three@0.136.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.136.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://unpkg.com/gsap@3/dist/gsap.min.js"></script>

  <script>
    console.clear();

    // ====== Setup ======
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 5000);
    camera.position.z = 500;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(devicePixelRatio > 1 ? 2 : 1);
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enabled = true;
    controls.enablePan = false;
    controls.rotateSpeed = 0.9;
    controls.zoomSpeed = 1.0;

    // ====== Heart (Original mechanics, unchanged) ======
    const path = document.getElementById('heartPath');
    const length = path.getTotalLength();
    const step = 0.1;
    const centerX = 600 / 2;
    const centerY = 552 / 2;

    const heartVectors = [];
    for (let i = 0; i < length; i += step) {
      const p = path.getPointAtLength(i);
      const v = new THREE.Vector3(p.x, -p.y, 0);
      v.x += (Math.random() - 0.5) * 30;
      v.y += (Math.random() - 0.5) * 30;
      v.z += (Math.random() - 0.5) * 70;
      heartVectors.push(v);
    }

    const heartGeo = new THREE.BufferGeometry().setFromPoints(heartVectors);
    const heartMat = new THREE.PointsMaterial({ color: 0xee5282, blending: THREE.AdditiveBlending, size: 3, depthWrite:false });
    const heartPoints = new THREE.Points(heartGeo, heartMat);
    heartPoints.position.x -= centerX;
    heartPoints.position.y += centerY;
    scene.add(heartPoints);

    gsap.fromTo(scene.rotation, { y: -0.2 }, { y: 0.2, repeat: -1, yoyo: true, ease:'power2.inOut', duration:3 });

    // ====== Text Canvas (only drawing parameters preserved) ======
    const canvas = document.createElement('canvas');
    canvas.width = 600; canvas.height = 552;
    const ctx = canvas.getContext('2d');

    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.font = "bold 70px 'Segoe Script', 'Pacifico', cursive, Arial";
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = '#ffffff';
    // moved slightly up earlier; kept here
    ctx.fillText('happy anniversary', canvas.width/2, canvas.height/2 - 10);

    // dense sampling for clarity (unchanged)
    const sampleStepText = 1;
    const img = ctx.getImageData(0,0,canvas.width,canvas.height);
    const data = img.data;
    const textVertices = [];
    for (let y = 0; y < canvas.height; y += sampleStepText) {
      for (let x = 0; x < canvas.width; x += sampleStepText) {
        const idx = (y * canvas.width + x) * 4;
        if (data[idx + 3] > 128) {
          const v = new THREE.Vector3(x, -y, 0);
          // reduced jitter kept from previous tweak
          v.x += (Math.random() - 0.5) * 2;
          v.y += (Math.random() - 0.5) * 2;
          v.z += (Math.random() - 0.5) * 10;
          textVertices.push(v);
        }
      }
    }

    // ====== <-- ONLY CHANGE #1: sort by X so letters form left-to-right -->
    textVertices.sort((a,b) => a.x - b.x || a.y - b.y);

    const textGeo = new THREE.BufferGeometry().setFromPoints(textVertices);
    const textMat = new THREE.PointsMaterial({ color: 0xee5282, blending: THREE.AdditiveBlending, size: 3, depthWrite:false });
    const textPoints = new THREE.Points(textGeo, textMat);
    textPoints.position.x -= centerX;
    textPoints.position.y += centerY;
    scene.add(textPoints);

    // ====== Animation Timeline (heart unchanged, text scheduled after heart) ======
    const tl = gsap.timeline({ repeat: -1, yoyo: true });

    for (let i = 0; i < heartVectors.length; i++) {
      tl.from(heartVectors[i], {
        x: centerX,
        y: -centerY,
        z: 0,
        ease: "power2.inOut",
        duration: gsap.utils.random(2,5)
      }, i * 0.002);
    }

    const heartDuration = tl.duration();

    for (let i = 0; i < textVertices.length; i++) {
      const v = textVertices[i];
      const startAt = heartDuration + i * 0.0016;
      tl.add(gsap.from(v, {
        x: centerX,
        y: -centerY,
        z: 0,
        ease: "power2.inOut",
        duration: gsap.utils.random(2,4),
        onUpdate: () => textGeo.setFromPoints(textVertices)
      }), startAt);
    }

    // ====== <-- ONLY CHANGE #2: speed up timeline by 1.5x (affects timing) -->
    tl.timeScale(1.5);

    // ====== Render Loop ======
    function render() {
      requestAnimationFrame(render);
      heartGeo.setFromPoints(heartVectors);
      textGeo.setFromPoints(textVertices);
      renderer.render(scene, camera);
    }
    render();

    window.addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>